from __future__ import annotations

import hashlib
import logging
import pathlib
from typing import TYPE_CHECKING, Any

import numpy as np
from sqlalchemy.dialects.postgresql import insert as pg_insert

from .connection import connect_to_db
from .models import Base

if TYPE_CHECKING:
    import pandas as pd
    from sqlalchemy import Engine
    from sqlalchemy.orm import Session
    from sqlalchemy.orm.decl_api import DeclarativeMeta

_logger = logging.getLogger(__name__)


def create_tables(engine: Engine | None = None) -> None:
    """Create tables in the PostgreSQL database."""
    _logger.info("Creating tables")
    try:
        if engine is None:
            engine = connect_to_db()

        Base.metadata.create_all(engine, checkfirst=True)

    except Exception as error:
        _logger.exception("Error during table creation: %r", error)  # noqa: TRY401
    finally:
        if engine is not None:
            engine.dispose()


def upsert_data_optimized(
    session: Session,
    df: pd.DataFrame,
    table_class: DeclarativeMeta,
    primary_key: str,
) -> int:
    """
    Optimized upsert for large DataFrames using pandas and SQLAlchemy.

    Args:
        session: SQLAlchemy session
        df (pd.DataFrame): DataFrame containing data to upsert
        table_class: SQLAlchemy table class
        primary_key: Primary key column name

    Returns
    -------
        int: Number of records processed
    """
    try:
        # convert nan to None
        # Convert to dict and remove SQLAlchemy internal attributes if present
        data_list = df.replace({np.nan: None}).to_dict("records")
        for record in data_list:
            record.pop("_sa_instance_state", None)
            record.pop("_sa_registry", None)

        # Use PostgreSQL ON CONFLICT
        stmt = pg_insert(table_class)
        stmt = stmt.values(data_list)
        stmt = stmt.on_conflict_do_update(
            index_elements=[primary_key], set_=dict(stmt.excluded)
        )
        session.execute(stmt)
        session.commit()
        return len(data_list)

    except Exception as e:
        session.rollback()
        _logger.exception("Error during upsert: %r", e)  # noqa: TRY401
        pathlib.Path("errors.log").write_text(
            f"Error during upsert: {e}",
            encoding="utf-8",
        )
        raise


def get_consistent_hash(seed_string: Any) -> str:
    obj_str = str(seed_string)
    sha256 = hashlib.sha256()
    sha256.update(obj_str.encode("utf-8"))
    return sha256.hexdigest()


def create_hash_id(
    df: pd.DataFrame,
    column_name: str,
    id_column: str = "id",
    position: int = 0,
) -> pd.DataFrame:
    """
    Create a hash ID column by combining specified columns and applying a consistent hash function.

    This function generates a new hash column by concatenating the values of the specified
    ID column and channel_name column, then applying a consistent hash
    function to the concatenated string.

    Args:
        df (pd.DataFrame): Input DataFrame containing the data to process
        column_name (str): Name of the new hash column to be created
        id_column (str, optional): Name of the ID column to include in hash calculation.
            Defaults to "id".
        position (int, optional): The position of the new column in the dataframe.

    Returns
    -------
        pd.DataFrame: DataFrame with the new hash column inserted at the beginning (index 0)

    Example:
        >>> df = pd.DataFrame({
        ...     'id': [1, 2, 3],
        ...     'channel_name': ["m6", "france3idf", "france2"],
        ... })
        >>> result_df = create_hash_id(df, 'hash_id')
        >>> print(result_df)
           hash_id      id  channel_name
        0  hash_value1   1          m6
        1  hash_value2   2  france3idf
        2  hash_value3   3     france2

    Note:
        - The function modifies the DataFrame in-place by inserting the new column at index 0
        - The hash is generated by concatenating id_columna and channel_name
        - Assumes 'channel_name' column exists in the DataFrame
    """  # noqa: E501
    df.insert(
        position,
        column_name,
        (df[id_column].astype(str) + df.channel_name.astype(str)).apply(
            get_consistent_hash
        ),
    )
    return df
